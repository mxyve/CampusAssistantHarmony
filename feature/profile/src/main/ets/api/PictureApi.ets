import promptAction from '@ohos.promptAction';
import http from '@ohos.net.http';
import { storageUtil } from 'storage';
import { BusinessError } from '@kit.BasicServicesKit';
import fs from '@ohos.file.fs';
import util from '@ohos.util';

interface DirectUploadResponse {
  code: number;
  message?: string;
  data?: string;
}

interface RequestHeaders {
  'Authorization': string;
  'Content-Type': string;
  'Content-Length': string; // æ–°å¢ï¼šContent-Lengthè¯·æ±‚å¤´
}

interface MultipartResult {
  data: Uint8Array;
  contentType: string;
}

// æ–°å¢ï¼šæ ¹æ®æ–‡ä»¶URIåˆ¤æ–­å›¾ç‰‡MIMEç±»å‹
function getImageMimeType(imageUri: string): string {
  const ext = imageUri.split('.').pop()?.toLowerCase() || 'jpg';
  switch (ext) {
    case 'png':
      return 'image/png';
    case 'gif':
      return 'image/gif';
    case 'webp':
      return 'image/webp';
    default:
      return 'image/jpeg'; // é»˜è®¤JPG
  }
}

async function readImageToUint8Array(imageUri: string): Promise<Uint8Array | null> {
  try {
    const file = await fs.open(imageUri, fs.OpenMode.READ_ONLY);
    if (!file || !file.fd) {
      console.error('âŒ æ–‡ä»¶å¥æŸ„è·å–å¤±è´¥');
      return null;
    }

    const fileStat = await fs.stat(file.fd);
    const maxSize = 5 * 1024 * 1024;
    if (fileStat.size <= 0 || fileStat.size > maxSize) {
      await fs.close(file);
      console.error('âŒ æ–‡ä»¶å¤§å°å¼‚å¸¸:', fileStat.size);
      promptAction.showToast({ message: 'å›¾ç‰‡å¤§å°éœ€åœ¨0-5MBä¹‹é—´' });
      return null;
    }

    await fs.lseek(file.fd, 0, 0);
    const buffer = new ArrayBuffer(fileStat.size);
    const readBytes = await fs.read(file.fd, buffer);
    if (readBytes !== fileStat.size) {
      await fs.close(file);
      console.error('âŒ å›¾ç‰‡è¯»å–ä¸å®Œæ•´ï¼Œé¢„æœŸ:', fileStat.size, 'å®é™…:', readBytes);
      promptAction.showToast({ message: 'å›¾ç‰‡è¯»å–ä¸å®Œæ•´ï¼Œè¯·æ¢ä¸€å¼ ' });
      return null;
    }

    await fs.close(file);
    const fileData = new Uint8Array(buffer);
    console.log('âœ… è¯»å–å›¾ç‰‡æˆåŠŸï¼Œå¤§å°:', fileData.length);
    return fileData;
  } catch (err) {
    console.error('âŒ è¯»å–å›¾ç‰‡å¤±è´¥:', err);
    promptAction.showToast({ message: 'å›¾ç‰‡è¯»å–å¤±è´¥ï¼Œè¯·æ¢ä¸€å¼ ' });
    return null;
  }
}

// ä¿®æ”¹1ï¼šæ¥æ”¶imageUriå‚æ•°ï¼ŒåŠ¨æ€è®¾ç½®MIMEç±»å‹
function buildMultipartFormData(fileData: Uint8Array, imageUri: string): MultipartResult {
  const boundary = '----WebKitFormBoundary' + Date.now();
  const textEncoder = new util.TextEncoder();
  // åŠ¨æ€è·å–MIMEç±»å‹
  const mimeType = getImageMimeType(imageUri);
  // ä¿®å¤ï¼šæ–‡ä»¶åä¿ç•™åŸåç¼€ï¼ŒMIMEç±»å‹åŠ¨æ€é€‚é…
  const fileName = imageUri.split('/').pop() || 'avatar.jpg';
  const headerStr = `--${boundary}\r\n` +
    `Content-Disposition: form-data; name="file"; filename="${fileName}"\r\n` +
    `Content-Type: ${mimeType}\r\n\r\n`; // ä¸å†ç¡¬ç¼–ç jpeg
  const headerBytes = textEncoder.encode(headerStr);
  const footerStr = `\r\n--${boundary}--\r\n`;
  const footerBytes = textEncoder.encode(footerStr);

  console.log('å¤´éƒ¨å¤§å°:', headerBytes.length);
  console.log('å°¾éƒ¨å¤§å°:', footerBytes.length);

  const totalLength = headerBytes.length + fileData.length + footerBytes.length;
  console.log('æ€»æ‹¼æ¥å¤§å°:', totalLength);
  const formData = new Uint8Array(totalLength);
  formData.set(headerBytes, 0);
  formData.set(fileData, headerBytes.length);
  formData.set(footerBytes, headerBytes.length + fileData.length);

  return {
    data: formData,
    contentType: `multipart/form-data; boundary=${boundary}`
  };
}

export class PictureApi {
  static async uploadAvatar(imageUri: string): Promise<string | null> {
    console.log('ğŸ“± å¼€å§‹ä¸Šä¼ å¤´åƒï¼ŒURI:', imageUri);

    const fileData = await readImageToUint8Array(imageUri);
    if (!fileData) {
      return null;
    }

    let token: string = '';
    try {
      const tokenValue = await storageUtil.get('token');
      token = tokenValue ? tokenValue.toString() : '';
      if (!token) {
        console.error('âŒ Tokenä¸ºç©º');
        promptAction.showToast({ message: 'ç™»å½•çŠ¶æ€å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•' });
        return null;
      }
    } catch (tokenErr) {
      console.error('âŒ è·å–Tokenå¤±è´¥:', tokenErr);
      promptAction.showToast({ message: 'é‰´æƒå¤±è´¥' });
      return null;
    }

    // ä¿®æ”¹2ï¼šè°ƒç”¨buildMultipartFormDataæ—¶ä¼ å…¥imageUri
    const multipartData = buildMultipartFormData(fileData, imageUri);
    console.log('è¯·æ±‚ä½“æ€»å¤§å°:', multipartData.data.length);

    return new Promise<string | null>((resolve) => {
      const httpRequest = http.createHttp();
      const uploadUrl = 'http://192.168.1.14:6060/api/v1/users/me/image';

      // ä¿®æ”¹3ï¼šæ–°å¢Content-Lengthè¯·æ±‚å¤´ï¼ˆTomcatè§£æå¿…éœ€ï¼‰
      const headers: RequestHeaders = {
        'Authorization': `Bearer ${token}`,
        'Content-Type': multipartData.contentType,
        'Content-Length': multipartData.data.length.toString() // å…³é”®ï¼šå‘Šè¯‰åç«¯è¯·æ±‚ä½“æ€»é•¿åº¦
      };

      // 1. åˆ›å»ºåŸç”Ÿ multiFormDataListï¼ˆä¸è¦æ‰‹åŠ¨æ‹¼ boundaryï¼‰
      const multiFormDataList: Array<http.MultiFormData> = [
        {
          name: 'file',
          contentType: getImageMimeType(imageUri),
          remoteFileName: imageUri.split('/').pop() || 'avatar.jpg',
          data: fileData.buffer          // ArrayBuffer
        }
      ];

      console.log('ğŸŒ å‘é€ä¸Šä¼ è¯·æ±‚åˆ°:', uploadUrl);
      httpRequest.request(
        uploadUrl,
        {
          method: http.RequestMethod.POST,
          header: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'multipart/form-data'   // è®©é¸¿è’™è‡ªåŠ¨è¡¥ boundary
          },
          multiFormDataList: multiFormDataList
        },
        (err: BusinessError, response: http.HttpResponse) => {
          httpRequest.destroy();

          if (err) {
            console.error('âŒ ä¸Šä¼ è¯·æ±‚å¤±è´¥:', err);
            promptAction.showToast({
              message: `ä¸Šä¼ å¤±è´¥: ${err.message || 'ç½‘ç»œå¼‚å¸¸'}`
            });
            resolve(null);
            return;
          }

          try {
            console.log('âœ… ä¸Šä¼ è¯·æ±‚å“åº”çŠ¶æ€ç :', response.responseCode);
            let responseData: DirectUploadResponse;

            if (typeof response.result === 'string') {
              responseData = JSON.parse(response.result) as DirectUploadResponse;
            } else {
              responseData = response.result as DirectUploadResponse;
            }

            console.log('ğŸ“¦ ä¸Šä¼ å“åº”æ•°æ®:', responseData);

            if (responseData && responseData.code === 200 && responseData.data) {
              promptAction.showToast({ message: 'å¤´åƒä¸Šä¼ æˆåŠŸ' });
              resolve(responseData.data);
            } else {
              console.error('âŒ æœåŠ¡å™¨è¿”å›å¤±è´¥:', responseData?.message);
              promptAction.showToast({
                message: responseData?.message || 'ä¸Šä¼ å¤±è´¥ï¼ŒæœåŠ¡å™¨å¤„ç†å¼‚å¸¸'
              });
              resolve(null);
            }
          } catch (parseErr) {
            console.error('âŒ è§£æå“åº”å¤±è´¥:', parseErr);
            promptAction.showToast({ message: 'ä¸Šä¼ å“åº”è§£æå¤±è´¥' });
            resolve(null);
          }
        }
      );
    });
  }
}