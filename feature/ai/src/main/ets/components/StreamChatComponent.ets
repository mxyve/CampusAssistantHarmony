import { MessageApi, StreamChatOptions, SSEStreamController } from '../api/MessageApi';
import { MessageBubble } from '../components/MessageBubble';
import { storageUtil } from 'storage';
import promptAction from '@ohos.promptAction';
import { GenerateSessionTitleParams, SessionApi } from '../api/SessionApi';

// å¯¹å¤–æš´éœ²çš„å±æ€§
interface StreamChatComponentProps {
  sessionId: number; // ä¼šè¯ID
  initialMessages: MessageItem[]; // åˆå§‹å†å²æ¶ˆæ¯
  userId: number; // å½“å‰ç”¨æˆ·ID
  isLoggedIn: boolean; // ç™»å½•çŠ¶æ€
  onSendMessage: (message: string) => Promise<void>; // æ¶ˆæ¯å‘é€å›è°ƒ
}

// æ¶ˆæ¯é¡¹ç±»å‹ï¼ˆå’ŒåŸé¡µé¢ä¿æŒä¸€è‡´ï¼‰
export interface MessageItem {
  id: number;
  sessionId: number;
  userId: number;
  role: 'user' | 'assistant';
  content: string;
  modelName: string;
  status: number;
  statusDesc: string;
  createTime: string;
}

export interface SendMessageEvent {
  action: 'sendFirstMessage'; // å›ºå®šå€¼ç±»å‹
  sessionId: number;
  message: string;
}

@Component
export struct StreamChatComponent {
  @Prop sessionId: number;
  @Prop initialMessages: MessageItem[];
  @Prop userId: number;
  @Prop isLoggedIn: boolean;
  @State messageList: MessageItem[] = [];
  @State inputText: string = '';
  @State isSending: boolean = false;
  @State currentAssistantMessage: MessageItem | null = null;
  private streamController: SSEStreamController | null = null;
  @State isNewSession: boolean = false;
  @State hasGeneratedTitle: boolean = false;

  // ç»„ä»¶åˆå§‹åŒ–ï¼šåŒæ­¥åˆå§‹å†å²æ¶ˆæ¯
  aboutToAppear() {
    this.messageList = [...this.initialMessages];
    this.isNewSession = this.initialMessages.length === 0;
    console.log(`ğŸ”ä¼šè¯${this.sessionId}æ˜¯å¦ä¸ºæ–°å»º:`, this.isNewSession);
  }

  build() {
    Column() {
      // æ¶ˆæ¯åˆ—è¡¨
      Scroll() {
        Column({ space: 16 }) {
          ForEach(this.messageList, (item: MessageItem) => {
            MessageBubble({
              content: item.content,
              isUser: item.role === 'user',
              time: this.formatTime(item.createTime),
              statusDesc: item.statusDesc,
              isAssistant: item.role === 'assistant',
              userAvatar: $r('app.media.avatar_img'),
              aiAvatar: $r('app.media.robot')
            })
          })

          // æ­£åœ¨å›å¤çš„AIæ¶ˆæ¯
          if (this.currentAssistantMessage) {
            MessageBubble({
              content: this.currentAssistantMessage.content,
              isUser: false,
              time: '',
              statusDesc: this.currentAssistantMessage.statusDesc,
              isAssistant: true,
              userAvatar: $r('app.media.avatar_img'),
              aiAvatar: $r('app.media.robot')
            })
          }
        }
        .padding(16)
        .width('100%')
      }
      .layoutWeight(1)

      // è¾“å…¥æ¡†åŒºåŸŸï¼ˆå°è£…åˆ°ç»„ä»¶å†…ï¼Œä¹Ÿå¯æš´éœ²ä¸ºslotï¼‰
      this.buildInputArea()
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F8F9FA')
  }

  @Builder
  buildInputArea() {
    Row({ space: 8 }) {
      TextInput({ text: this.inputText })
        .layoutWeight(1)
        .backgroundColor('#FFFFFF')
        .borderColor('#E5E6EB')
        .borderWidth(1)
        .borderRadius(20)
        .padding({ left: 16, right: 16 })
        .height(40)
        .onChange((value: string) => {
          this.inputText = value;
        })
        .onSubmit(() => {
          if (this.inputText.trim() && !this.isSending) {
            this.sendMessage();
          }
        })

      Button(this.isSending ? 'å‘é€ä¸­...' : 'å‘é€', { type: ButtonType.Normal })
        .fontSize(14)
        .backgroundColor(this.isSending ? '#A0CFFF' : '#337EFF')
        .fontColor('#FFFFFF')
        .borderRadius(20)
        .width(80)
        .height(40)
        .enabled(!this.isSending && !!this.inputText.trim())
        .onClick(() => {
          this.sendMessage();
        })
    }
    .padding(16)
    .backgroundColor('#FFFFFF')
    .borderColor('#E5E6EB')
    .borderWidth({ top: 1 })
  }

  // æ ¸å¿ƒï¼šå‘é€æ¶ˆæ¯+SSEæµå¼å¤„ç†ï¼ˆåŸé¡µé¢çš„sendMessageé€»è¾‘è¿ç§»ï¼‰
  private async sendMessage() {
    if (!this.inputText.trim() || this.isSending || !this.isLoggedIn) {
      if (!this.isLoggedIn) {
        promptAction.showToast({ message: 'è¯·å…ˆç™»å½•åå†å‘é€æ¶ˆæ¯' });
      }
      return;
    }

    // ç”¨æˆ·æ¶ˆæ¯
    const userMessage = this.inputText.trim();

    if (this.isNewSession && !this.hasGeneratedTitle && this.messageList.length === 0) {
      console.log(`ğŸ“¢æ–°å»ºä¼šè¯${this.sessionId}ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼Œå¼€å§‹ç”Ÿæˆæ ‡é¢˜:`, userMessage);
      await this.callGenerateTitleApi(userMessage);
      this.hasGeneratedTitle = true; // æ ‡è®°å·²ç”Ÿæˆï¼Œé¿å…é‡å¤
    }

    // 1. è·å–Token
    let token = '';
    try {
      const storageToken = await storageUtil.get('token');
      token = storageToken ? storageToken.toString() : '';
    } catch (error) {
      console.error('è·å–Tokenå¤±è´¥:', error);
      return;
    }

    this.inputText = '';
    this.isSending = true;

    const userMsgItem: MessageItem = {
      id: Date.now(),
      sessionId: this.sessionId,
      userId: this.userId,
      role: 'user',
      content: userMessage,
      modelName: 'qwen-turbo',
      status: 1,
      statusDesc: 'æˆåŠŸ',
      createTime: new Date().toISOString()
    };

    const assistantMsgItem: MessageItem = {
      id: Date.now() + 1,
      sessionId: this.sessionId,
      userId: 0,
      role: 'assistant',
      content: '',
      modelName: 'qwen-turbo',
      status: 0,
      statusDesc: 'æ€è€ƒä¸­...',
      createTime: new Date().toISOString()
    };

    // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
    this.messageList = [...this.messageList, userMsgItem];
    this.currentAssistantMessage = assistantMsgItem;

    try {
      // å…³é—­æ—§è¿æ¥
      this.streamController?.close();
      this.streamController = null;
      let accumulatedContent = '';

      // 3. æ„å»ºSSEè¯·æ±‚
      const streamOptions: StreamChatOptions = {
        token: token,
        params: {
          sessionId: this.sessionId,
          modelName: 'qwen-turbo',
          content: userMessage
        },
        onMessage: (data: string) => {
          const lines = data.split('\n');
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine) {
              continue;
            }

            if (trimmedLine.startsWith('data:')) {
              const content = trimmedLine.substring(5).trim();
              if (content === '[DONE]') {
                this.handleStreamEnd(accumulatedContent, true);
                return;
              }
              if (content) {
                accumulatedContent += content;
                this.updateAssistantMessage(accumulatedContent, 'å›å¤ä¸­...');
              }
            } else {
              accumulatedContent += trimmedLine;
              this.updateAssistantMessage(accumulatedContent, 'å›å¤ä¸­...');
            }
          }
        },
        onError: (error: Error) => {
          console.error('SSEè¿æ¥é”™è¯¯:', error.message);
          const msg = error.message.includes('Token') ? 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•' : `è¯·æ±‚å¤±è´¥: ${error.message}`;
          promptAction.showToast({ message: msg });
          this.handleStreamEnd(msg, false);
        },
        onComplete: () => {
          this.handleStreamEnd(accumulatedContent || 'æ— å›å¤å†…å®¹', true);
        }
      };

      // 4. å‘èµ·SSEè¯·æ±‚
      this.streamController = await MessageApi.streamChat(streamOptions);
      if (!this.streamController) {
        throw new Error('æ— æ³•åˆ›å»ºSSEè¿æ¥');
      }

      // è¶…æ—¶æ£€æµ‹
      setTimeout(() => {
        if (this.isSending && accumulatedContent === '') {
          this.handleStreamEnd('è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•', false);
        }
      }, 30000);

    } catch (error) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
      this.handleStreamEnd(`å‘é€å¤±è´¥: ${(error as Error).message}`, false);
    }
  }

  // æ›´æ–°AIå›å¤å†…å®¹ï¼ˆæŠ½ç¦»çš„è¾…åŠ©æ–¹æ³•ï¼‰
  private updateAssistantMessage(content: string, statusDesc: string) {
    if (this.currentAssistantMessage) {
      this.currentAssistantMessage = {
        id: this.currentAssistantMessage.id,
        sessionId: this.currentAssistantMessage.sessionId,
        userId: this.currentAssistantMessage.userId,
        role: this.currentAssistantMessage.role,
        content: content, // ä»…æ›´æ–°å†…å®¹
        modelName: this.currentAssistantMessage.modelName,
        status: this.currentAssistantMessage.status,
        statusDesc: statusDesc, // ä»…æ›´æ–°çŠ¶æ€
        createTime: this.currentAssistantMessage.createTime
      };
    }
  }

  // æµå¼ç»“æŸå¤„ç†ï¼ˆåŸé¡µé¢çš„handleStreamEndé€»è¾‘è¿ç§»ï¼‰
  private handleStreamEnd(content: string, success: boolean) {
    if (this.currentAssistantMessage) {
      const completedMsg: MessageItem = {
        id: this.currentAssistantMessage.id,
        sessionId: this.currentAssistantMessage.sessionId,
        userId: this.currentAssistantMessage.userId,
        role: this.currentAssistantMessage.role,
        content: content,
        modelName: this.currentAssistantMessage.modelName,
        status: success ? 1 : 2,
        statusDesc: success ? 'æˆåŠŸ' : 'å¤±è´¥',
        createTime: new Date().toISOString()
      };
      this.messageList = [...this.messageList, completedMsg];
      this.currentAssistantMessage = null;
    }

    // æ¸…ç†èµ„æº
    this.streamController?.close();
    this.streamController = null;
    this.isSending = false;
  }

  // å·¥å…·æ–¹æ³•ï¼šæ ¼å¼åŒ–æ—¶é—´
  private formatTime(timeStr: string): string {
    if (!timeStr) {
      return '';
    }
    try {
      const date = new Date(timeStr);
      return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
    } catch (e) {
      return '';
    }
  }

  // ç»„ä»¶é”€æ¯æ—¶å…³é—­è¿æ¥
  aboutToDisappear() {
    this.streamController?.close();
  }

  private async callGenerateTitleApi(userMessage: string) {
    try {
      const params: GenerateSessionTitleParams = {
        userFirstMessage: userMessage.trim()
      };
      const result = await SessionApi.generateSessionTitle(this.sessionId, params);

      if (result) {
        console.log(`ğŸ¤–ä¼šè¯${this.sessionId}è‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜æˆåŠŸ:`, result.title);
        // é€šçŸ¥ChatPageæ›´æ–°æ ‡é¢˜
        postCardAction(this, {
          action: 'updateSessionTitle',
          params: {
            sessionId: this.sessionId,
            title: result.title
          }
        });
      } else {
        console.error(`âŒä¼šè¯${this.sessionId}ç”Ÿæˆæ ‡é¢˜æ¥å£è¿”å›null`);
      }
    } catch (error) {
      console.error(`âŒä¼šè¯${this.sessionId}è°ƒç”¨ç”Ÿæˆæ ‡é¢˜æ¥å£å¼‚å¸¸:`, error);
    }
  }
}